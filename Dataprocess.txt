/* Assign the library for CRSP data */
libname crspdata 'C:\Users\Shi\ucl\raw data'; 

/* Check dataset structure */
proc contents data=crspdata.CRSP_DAILY;
run;

/* Step 1: Inspect structure and variable names */
proc contents data=crspdata.CRSP_DAILY;
    title "CRSP_DAILY Dataset Structure";
run;

/* View first 10 observations to confirm variable names */
proc print data=crspdata.CRSP_DAILY (obs=10);
    title "First 10 Observations of CRSP_DAILY";
run;

/* Data preparation and sorting */
proc sort data=crspdata.CRSP_DAILY out=crsp_sorted;
    by PERMNO date;  /* changed to PERMNO */
    where ret is not null;
run;

/* 1) Compute daily bid-ask spread */
proc sql;
    create table daily_spread as
    select 
        PERMNO,  /* changed to PERMNO */
        date,
        year(date) as year,
        /* Daily relative bid-ask spread */
        case when ask > 0 and bid > 0 and ask > bid 
             then (ask - bid) / ((ask + bid) / 2) 
             else . end as daily_spread format=percent8.4,
        ask,
        bid,
        (ask - bid) as absolute_spread  /* Absolute spread */
    from crsp_sorted
    where ask > 0 and bid > 0 and ask > bid;
quit;

/* Compute annual average bid-ask spread */
proc sql;
    create table annual_avg_spread as
    select 
        PERMNO,  /* changed to PERMNO */
        year,
        mean(daily_spread) as annual_avg_spread format=percent8.4,
        count(*) as trading_days,
        min(date) as first_date,
        max(date) as last_date
    from daily_spread
    group by PERMNO, year  /* changed to PERMNO */
    having count(*) >= 120  /* at least 120 trading days */
    order by PERMNO, year;  /* changed to PERMNO */
quit;

/* Compute lagged (t-1) annual spread */
data annual_spread_lag1;
    set annual_avg_spread;
    by PERMNO year;  /* changed to PERMNO */
    
    /* Get lagged annual spread */
    lag1_annual_spread = lag(annual_avg_spread);
    lag1_year = lag(year);
    
    /* Ensure within the same stock */
    if first.PERMNO then do;  /* changed to PERMNO */
        lag1_annual_spread = .;
        lag1_year = .;
    end;
    
    /* Keep only valid lag observations */
    if not missing(lag1_annual_spread) and year = lag1_year + 1;
    
    keep PERMNO year annual_avg_spread lag1_annual_spread lag1_year trading_days;  /* changed to PERMNO */
    format annual_avg_spread lag1_annual_spread percent8.4;
run;

/* Compute daily market-adjusted returns */
proc sql;
    create table daily_adjusted_returns as
    select 
        PERMNO,  /* changed to PERMNO */
        date,
        year(date) as year,
        
        /* Stock daily return (including delisting return) */
        coalesce(ret, 0) + coalesce(dlret, 0) as daily_stock_return,
        
        /* Market daily return */
        vwretd as daily_market_return,
        
        /* Daily market-adjusted return */
        (1 + coalesce(ret, 0) + coalesce(dlret, 0)) / (1 + vwretd) - 1 as daily_adjusted_return,
        
        /* Raw return used for volatility calculation */
        coalesce(ret, 0) as daily_raw_return
        
    from crspdata.CRSP_DAILY
    where ret is not null or dlret is not null;
quit;

/* Compute annual market-adjusted return */
proc sql;
    create table annual_adjusted_returns as
    select 
        PERMNO,  /* changed to PERMNO */
        year,
        
        /* Annual market-adjusted return - geometric compounding */
        exp(sum(log(1 + daily_adjusted_return))) - 1 as annual_adjusted_return format=percent8.2,
        
        /* Auxiliary statistics */
        count(*) as trading_days,
        mean(daily_adjusted_return) as avg_daily_adjusted_return format=percent8.4,
        std(daily_adjusted_return) as std_daily_adjusted_return format=percent8.4,
        min(daily_adjusted_return) as min_daily_adjusted_return format=percent8.4,
        max(daily_adjusted_return) as max_daily_adjusted_return format=percent8.4
        
    from daily_adjusted_returns
    where not missing(daily_adjusted_return)
    group by PERMNO, year 
    having count(*) >= 120  /* at least 120 trading days */
    order by PERMNO, year;  
quit;

/* Get lagged annual market-adjusted return */
data annual_adjusted_returns_lag;
    set annual_adjusted_returns;
    by PERMNO year;  
    
    /* Lagged annual adjusted return */
    lag1_annual_adjusted_return = lag(annual_adjusted_return);
    lag1_year = lag(year);
    lag1_trading_days = lag(trading_days);
    
    /* Ensure within same stock */
    if first.PERMNO then do;  /* changed to PERMNO */
        lag1_annual_adjusted_return = .;
        lag1_year = .;
        lag1_trading_days = .;
    end;
    
    keep PERMNO year annual_adjusted_return lag1_annual_adjusted_return  
         trading_days lag1_trading_days lag1_year
         avg_daily_adjusted_return std_daily_adjusted_return;
    
    format annual_adjusted_return lag1_annual_adjusted_return percent8.2
           avg_daily_adjusted_return std_daily_adjusted_return percent8.4;
run;

/* Compute annualized volatility - standard method */
proc sql;
    create table annual_volatility as
    select 
        PERMNO,  
        year(date) as year,
        
        /* Annualized volatility = std of daily returns × sqrt(252) */
        std(ret) * sqrt(252) as annual_volatility format=percent8.2,
        
        /* Auxiliary statistics */
        count(*) as trading_days,
        mean(ret) as avg_daily_return format=percent8.4,
        min(ret) as min_daily_return format=percent8.4,
        max(ret) as max_daily_return format=percent8.4,
        std(ret) as daily_volatility format=percent8.4
        
    from crsp_sorted
    where ret is not null
    group by PERMNO, calculated year  
    having count(*) >= 120  /* at least 120 trading days */
    order by permno, year;  
quit;

/* Ensure correct ordering of annual volatility */
proc sort data=annual_volatility;
    by PERMNO year;  

data lag_volatility_data;
    set annual_volatility;
    by PERMNO;  
    /* Set volatility to previous year's value */
    annual_volatility = lag(annual_volatility);
    /* Remove first observation per PERMNO (no previous year) */
    if not first.PERMNO; 
    format annual_volatility percent8.2;
run;

proc print data=lag_volatility_data (obs=20);
    title "Data Using Previous Year's Volatility";
run;

/* Export market data (merged) */
proc sql;
    create table CRSP_data_clean as
    select 
        s.PERMNO,  
        s.year,
        
        /* Spread metrics */
        s.annual_avg_spread,
        s.lag1_annual_spread,
        s.trading_days as spread_days,
        
        /* Same-year return metrics */
        r.annual_adjusted_return,
        r.trading_days as return_days,
        
        /* Lagged (t-1) return metrics */
        r_lag.annual_adjusted_return as lag1_annual_adjusted_return,
        r_lag.trading_days as lag1_return_days,
        r_lag.year as reference_year,  /* actual year corresponding to lagged data */
        
        /* Volatility metrics */
        v.annual_volatility,
        v.trading_days as vol_days
        
    from annual_spread_lag1 s
    left join annual_adjusted_returns r 
        on s.PERMNO = r.PERMNO and s.year = r.year  
    left join annual_adjusted_returns r_lag 
        on s.PERMNO = r_lag.PERMNO and s.year = r_lag.year + 1  
    left join lag_volatility_data v 
        on s.PERMNO = v.PERMNO and s.year = v.year  
    order by s.PERMNO, s.year;  
quit;

/* Export to CSV */
proc export data=CRSP_data_clean
    outfile="C:\Users\Shi\ucl\raw data\CRSP_YEAR_CLEAN.csv"
    dbms=csv replace;
run;

/* ===== Audit data processing ===== */

/* Import audit fee data */
proc import datafile="C:\Users\Shi\ucl\raw data\audit_fee.csv"
    out=audit_fee
    dbms=csv replace;
    guessingrows=1000;
run;

/* Sort by FISCAL_YEAR */
proc sort data=audit_fee out=audit_fee_sorted;
    by FISCAL_YEAR;
run;

/* Compute percentile ranks */
proc rank data=audit_fee_sorted out=ranked groups=100;
    by FISCAL_YEAR;  
    var AUDIT_FEES NON_AUDIT_FEES TOTAL_FEES;
    ranks audit_rank non_audit_rank total_rank;
run;

/* Compute required metrics */
data audit_fee_final;
    set ranked;
    
    /* New variables */
    cik = COMPANY_FKEY;
    fyear = FISCAL_YEAR;
    
    /* Logs — safe handling for zero and negative values */
    if AUDIT_FEES > 0 then ln_audit_fees = log(AUDIT_FEES);
    else if AUDIT_FEES = 0 then ln_audit_fees = 0;  /* set zero to 0 */
    else ln_audit_fees = .;  /* negatives set to missing */
    
    if NON_AUDIT_FEES > 0 then ln_non_audit_fees = log(NON_AUDIT_FEES);
    else if NON_AUDIT_FEES = 0 then ln_non_audit_fees = 0;
    else ln_non_audit_fees = .;
    
    if TOTAL_FEES > 0 then ln_total_fees = log(TOTAL_FEES);
    else if TOTAL_FEES = 0 then ln_total_fees = .;
    else ln_total_fees = .;
    
    /* Ratios — safe divide-by-zero handling */
    if TOTAL_FEES > 0 then do;
        audit_ratio = AUDIT_FEES / TOTAL_FEES;
        non_audit_ratio = NON_AUDIT_FEES / TOTAL_FEES;
    end;
    else do;
        audit_ratio = .;
        non_audit_ratio = .;
    end;
    
    /* Convert rank to percentile (0–1 range) */
    audit_fees_pctrank     = audit_rank / 99;     /* 0–1 range */
    non_audit_fees_pctrank = non_audit_rank / 99;
    total_fees_pctrank     = total_rank / 99;

    /* Formatting */
    format audit_fees_pctrank non_audit_fees_pctrank total_fees_pctrank percent8.1;
    format audit_ratio non_audit_ratio percent8.2;
    
    keep cik fyear AUDIT_FEES NON_AUDIT_FEES TOTAL_FEES
         ln_audit_fees ln_non_audit_fees ln_total_fees
         audit_ratio non_audit_ratio
         audit_fees_pctrank non_audit_fees_pctrank total_fees_pctrank;
run;

/* View first 20 rows */
proc print data=audit_fee_final (obs=20);
    title "First 20 Rows of Processed Audit-Fee Data";
run;

/* Export to CSV */
proc export data=audit_fee_final
    outfile="C:\Users\Shi\ucl\raw data\Audit_Fee_clean.csv"
    dbms=csv replace;
run;

/* ===== Board / Governance processing ===== */
libname board "C:\Users\Shi\ucl\raw data\";

/* Frequency of rowtype */
proc freq data=board.board;
    tables rowtype / missing;
    title "Distribution of 'rowtype'";
run;

/* Filter: keep rowtype = 'BOARD MEMBER' */
data board_members;
    set board.board;
    where upcase(strip(rowtype)) = 'BOARD MEMBER';
run;

/* Sanity check: counts */
proc means data=board_members n;
    title "Count of Filtered Observations (BOARD MEMBER)";
run;

proc contents data=board.board varnum;
run;

/* Sort by companyid and annualreportdate */
proc sort data=board.board out=sorted_board;
    by companyid annualreportdate;
run;

/* List unique role names */
proc sql;
    create table role_summary as
    select 
        distinct strip(upcase(rolename)) as role_name
    from board.board
    where not missing(rolename)
    order by calculated role_name;
quit;

proc print data=role_summary;
    title "All Distinct Role Names";
run;

/* Chairman-CEO duality and selected variables */
proc sql;
    create table chairman_ceo_duality as
    select 
        companyid,
        year(annualreportdate) as fyear,
        
        /* Check if a record shows both CHAIRMAN and CEO in the role name */
        max(case 
            when index(upcase(rolename), 'CHAIRMAN') > 0 and 
                 index(upcase(rolename), 'CEO') > 0 
            then 1 
            else 0 
        end) as chairman_ceo_duality,
        
        /* Keep needed variables */
        max(genderratio) as genderratio,
        max(numberdirectors) as numberdirectors,
        
        /* Optional: counts */
        count(distinct directorid) as total_directors,
        count(*) as total_records
        
    from board.board
    group by companyid, calculated fyear
    order by companyid, calculated fyear;
quit;

/* Keep only selected variables */
data chairman_ceo_final;
    set chairman_ceo_duality; 
    keep companyid fyear chairman_ceo_duality genderratio numberdirectors;
run;

proc print data=chairman_ceo_final (obs=20);
    title "First 20 Rows of Processed Board/Governance Data";
run;

/* Export governance metrics */
proc export data=chairman_ceo_final
    outfile="C:\Users\Shi\ucl\raw data\governance_metrics.csv"
    dbms=csv
    replace;
run;

/* ===== Final merging ===== */

/* Import all datasets */
proc import datafile="data_FraudDetection_JAR2020.csv" out=main_data dbms=csv replace;
    getnames=yes;
    guessingrows=1000;
run;

proc import datafile="codelink.csv" out=codelink dbms=csv replace;
    getnames=yes;
    guessingrows=1000;
run;

proc import datafile="crsp_comp.csv" out=crsp_comp dbms=csv replace;
    getnames=yes;
    guessingrows=1000;
run;

proc import datafile="Audit_Fee_clean.csv" out=audit_fee dbms=csv replace;
    getnames=yes;
    guessingrows=1000;
run;

proc import datafile="CRSP_YEAR_CLEAN.csv" out=crsp_year dbms=csv replace;
    getnames=yes;
    guessingrows=1000;
run;

proc import datafile="governance_metrics.csv" out=governance dbms=csv replace;
    getnames=yes;
    guessingrows=1000;
run;

/* Step 2: Filter main dataset to 2000–2014 */
data main_data_filtered;
    set main_data;
    where fyear >= 2000 and fyear <= 2014;
run;

/* 1) Ensure both datasets are sorted by gvkey and fyear */
proc sort data=main_data_filtered;
    by gvkey fyear;
run;

proc sort data=crsp_comp;
    by gvkey fyear;
run;

/* Merge CRSP mapping (LPERMNO/LPERMCO/CIK) */
proc sql;
    create table main_data_with_crsp as
    select 
        a.*,           /* all variables from data_FraudDetection_JAR2020 */
        b.LPERMNO,     /* add LPERMNO from crsp_comp */
        b.LPERMCO,     /* add LPERMCO from crsp_comp */
        b.CIK          /* add CIK from crsp_comp */
    from main_data_filtered a
    left join crsp_comp b
        on a.gvkey = b.gvkey and a.fyear = b.fyear;
quit;

/* Check merge results: missingness */
proc means data=main_data_with_crsp n nmiss;
    var LPERMNO LPERMCO;
    title "Missingness After Merging Main with CRSP Mapping";
run;

/* Preview merged data */
proc print data=main_data_with_crsp (obs=20);
    var gvkey fyear LPERMNO LPERMCO;
    title "First 20 Observations After Merging Main with CRSP";
run;

/* Match rates */
proc sql;
    select 
        count(*) as total_observations,
        sum(case when LPERMNO is not null then 1 else 0 end) as matched_permno,
        sum(case when LPERMCO is not null then 1 else 0 end) as matched_permco,
        calculated matched_permno / calculated total_observations as permno_match_rate format=percent8.2,
        calculated matched_permco / calculated total_observations as permco_match_rate format=percent8.2
    from main_data_with_crsp;
quit;

/* Merge codelink (companyid/PERMCO) */
proc sql;
    create table main_data_with_codelink as
    select 
        a.*,               /* all variables from main */
        b.companyid,       /* add companyid from codelink */
        b.PERMCO           /* add PERMCO from codelink */
    from main_data_with_crsp a
    left join codelink b
        on a.gvkey = b.gvkey;
quit;

/* Check merge result */
proc means data=main_data_with_codelink n nmiss;
    var companyid PERMCO;
    title "Missingness of companyid and PERMCO After Merge";
run;

/* Preview */
proc print data=main_data_with_codelink (obs=20);
    var gvkey fyear companyid PERMCO LPERMNO LPERMCO;
    title "First 20 Observations After Merging with codelink";
run;

/* Match rates after this step */
proc sql;
    select 
        count(*) as total_observations,
        sum(case when companyid is not null then 1 else 0 end) as matched_companyid,
        sum(case when LPERMCO is not null then 1 else 0 end) as matched_LPERMCO,
        sum(case when LPERMNO is not null then 1 else 0 end) as matched_LPERMNO,
        calculated matched_companyid / calculated total_observations as companyid_match_rate format=percent8.2,
        calculated matched_LPERMCO / calculated total_observations as LPERMCO_match_rate format=percent8.2,
        calculated matched_LPERMNO / calculated total_observations as LPERMNO_match_rate format=percent8.2
    from main_data_with_codelink;
quit;

/* Inspect variable lists before the final merge */
proc contents data=main_data_with_codelink;
    title "Variables in Main Dataset (Pre-Final Merge)";
run;

proc contents data=audit_fee;
    title "Variables in Audit Fee Dataset";
run;

proc contents data=crsp_year;
    title "Variables in CRSP Yearly Dataset";
run;

proc contents data=governance;
    title "Variables in Governance Dataset";
run;

/* Final merge of all datasets */
proc sql;
    create table FINAL_MERGED_DATASET as
    select 
        /* all variables from main */
        main.*,
        
        /* Audit fee variables */
        audit.ln_audit_fees,
        audit.ln_non_audit_fees,
        audit.ln_total_fees,
        audit.audit_ratio,
        audit.non_audit_ratio,
        audit.audit_fees_pctrank,
        audit.non_audit_fees_pctrank,
        audit.total_fees_pctrank,
        
        /* Market variables from CRSP_YEAR */
        crspyr.lag1_annual_spread,
        crspyr.annual_adjusted_return,
        crspyr.lag1_annual_adjusted_return,
        crspyr.annual_volatility,
        
        /* Governance variables */
        gov.chairman_ceo_duality,
        gov.genderratio,
        gov.numberdirectors
        
    from MAIN_DATA_WITH_CODELINK as main
    
    /* Merge audit fee data */
    left join AUDIT_FEE as audit
        on main.cik = audit.cik and main.fyear = audit.fyear
        
    /* Merge market data (treat CRSP_YEAR.year as fyear) */
    left join CRSP_YEAR as crspyr
        on main.LPERMNO = crspyr.PERMNO and main.fyear = crspyr.year
        
    /* Merge governance data */
    left join GOVERNANCE as gov
        on main.companyid = gov.companyid and main.fyear = gov.fyear
        
    order by main.gvkey, main.fyear;
quit;

/* Inspect final merged dataset */
proc contents data=final_merged_dataset;
    title "Structure of Final Merged Dataset";
run;

/* Show first 100 observations (trim output) */
proc print data=final_merged_dataset (obs=100);
    title "First 100 Observations of Final Dataset - All Variables";
run;

/* Keep rows with valid CRSP mapping */
data final_merged_dataset_clean;
    set final_merged_dataset;
    where not missing(LPERMNO) and not missing(LPERMCO);
run;

/* Alternative: enforce all key IDs to be non-missing */
proc sql;
    create table final_merged_dataset_clean as
    select *
    from final_merged_dataset
    where LPERMNO is not null and 
          LPERMCO is not null and
          cik is not null and 
          companyid is not null;
quit;

/* Compare counts before/after cleaning */
proc sql;
    title "Comparison Before and After Missingness Cleaning";
    select 
        (select count(*) from final_merged_dataset) as original_obs,
        (select count(*) from final_merged_dataset_clean) as cleaned_obs,
        calculated original_obs - calculated cleaned_obs as deleted_obs
    from final_merged_dataset(obs=1);
quit;

proc print data=final_merged_dataset_clean (obs=100);
    title "First 100 Observations of Cleaned Dataset - All Variables";
run;

proc contents data=final_merged_dataset_clean;
    title "Structure of Cleaned Final Merged Dataset";
run;

/* Save the final dataset */
data final_analysis_data;
    set final_merged_dataset_clean;
run;

/* Export to CSV */
proc export data=final_merged_dataset_clean
    outfile="final_merged_dataset.csv"
    dbms=csv replace;
run;
