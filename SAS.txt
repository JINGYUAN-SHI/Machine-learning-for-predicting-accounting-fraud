/*the raw dataset FraudDetection_JAR2020 contained 146,045 annual observations. After restricting the years to 2000–2014, the number of data points was reduced to 87411. Multiple merges yielded 96,470 annual observations, indicating that other databases may have generated more annual observations than the primary dataset during the data period. Subsequently, data lacking PERMCO and PERMNO were excluded, as these identifiers precluded imputation methods like median, mean, or mode filling used for other missing data. This operation removed 35,773 annual observations, yielding a final sample size of 60,697. Alternatively, deleting all records with missing values would have resulted in 32,731 annual data points. This approach would have entailed substantial data loss and potentially introduced selection bias. Consequently, the final sample size of 60,697 was selected for forecasting.*/

/* 首先分配CRSP数据所在的库 */
libname crspdata 'C:\Users\MichealZhang\Desktop\ucl\raw data'; 

/* 然后查看数据集结构 */
proc contents data=crspdata.CRSP_DAILY;
run;

/* 第一步：检查数据结构和变量名 */
proc contents data=crspdata.CRSP_DAILY;
    title "CRSP_DAILY数据集结构";
run;

/* 查看前10个观测，确认变量名 */
proc print data=crspdata.CRSP_DAILY (obs=10);
    title "CRSP_DAILY前10个观测";
run;

/* 数据准备和排序 */
proc sort data=crspdata.CRSP_DAILY out=crsp_sorted;
    by PERMNO date;  /* 改为 PERMNO */
    where ret is not null;
run;

/* 1. 先计算日度买卖差价 */
proc sql;
    create table daily_spread as
    select 
        PERMNO,  /* 改为 PERMNO */
        date,
        year(date) as year,
        /* 计算日度相对买卖差价 */
        case when ask > 0 and bid > 0 and ask > bid 
             then (ask - bid) / ((ask + bid) / 2) 
             else . end as daily_spread format=percent8.4,
        ask,
        bid,
        (ask - bid) as absolute_spread  /* 绝对价差 */
    from crsp_sorted
    where ask > 0 and bid > 0 and ask > bid;
quit;

/* 首先计算年度平均买卖差价 */
proc sql;
    create table annual_avg_spread as
    select 
        PERMNO,  /* 改为 PERMNO */
        year,
        mean(daily_spread) as annual_avg_spread format=percent8.4,
        count(*) as trading_days,
        min(date) as first_date,
        max(date) as last_date
    from daily_spread
    group by PERMNO, year  /* 改为 PERMNO */
    having count(*) >= 120  /* 至少120个交易日 */
    order by PERMNO, year;  /* 改为 PERMNO */
quit;

/* 计算滞后一期的年度差价 */
data annual_spread_lag1;
    set annual_avg_spread;
    by PERMNO year;  /* 改为 PERMNO */
    
    /* 获取滞后一期的年度差价 */
    lag1_annual_spread = lag(annual_avg_spread);
    lag1_year = lag(year);
    
    /* 确保是同一个股票 */
    if first.PERMNO then do;  /* 改为 PERMNO */
        lag1_annual_spread = .;
        lag1_year = .;
    end;
    
    /* 只保留有滞后数据的观测 */
    if not missing(lag1_annual_spread) and year = lag1_year + 1;
    
    keep PERMNO year annual_avg_spread lag1_annual_spread lag1_year trading_days;  /* 改为 PERMNO */
    format annual_avg_spread lag1_annual_spread percent8.4;
run;

/* 先计算每日的市场调整收益 */
proc sql;
    create table daily_adjusted_returns as
    select 
        PERMNO,  /* 改为 PERMNO */
        date,
        year(date) as year,
        
        /* 个股日收益率（包含退市回报） */
        coalesce(ret, 0) + coalesce(dlret, 0) as daily_stock_return,
        
        /* 市场日收益率 */
        vwretd as daily_market_return,
        
        /* 每日市场调整收益 */
        (1 + coalesce(ret, 0) + coalesce(dlret, 0)) / (1 + vwretd) - 1 as daily_adjusted_return,
        
        /* 原始收益率用于波动性计算 */
        coalesce(ret, 0) as daily_raw_return
        
    from crspdata.CRSP_DAILY
    where ret is not null or dlret is not null;
quit;

/* 计算年度市场调整收益率 */
proc sql;
    create table annual_adjusted_returns as
    select 
        PERMNO,  /* 改为 PERMNO */
        year,
        
        /* 年度市场调整收益率 - 使用几何平均 */
        exp(sum(log(1 + daily_adjusted_return))) - 1 as annual_adjusted_return format=percent8.2,
        
        /* 辅助统计量 */
        count(*) as trading_days,
        mean(daily_adjusted_return) as avg_daily_adjusted_return format=percent8.4,
        std(daily_adjusted_return) as std_daily_adjusted_return format=percent8.4,
        min(daily_adjusted_return) as min_daily_adjusted_return format=percent8.4,
        max(daily_adjusted_return) as max_daily_adjusted_return format=percent8.4
        
    from daily_adjusted_returns
    where not missing(daily_adjusted_return)
    group by PERMNO, year  /* 改为 PERMNO */
    having count(*) >= 120  /* 至少120个交易日 */
    order by PERMNO, year;  /* 改为 PERMNO */
quit;

/* 获取滞后一期年度市场调整收益率 */
data annual_adjusted_returns_lag;
    set annual_adjusted_returns;
    by PERMNO year;  /* 改为 PERMNO */
    
    /* 获取滞后一期的年度调整收益率 */
    lag1_annual_adjusted_return = lag(annual_adjusted_return);
    lag1_year = lag(year);
    lag1_trading_days = lag(trading_days);
    
    /* 确保是同一个股票 */
    if first.PERMNO then do;  /* 改为 PERMNO */
        lag1_annual_adjusted_return = .;
        lag1_year = .;
        lag1_trading_days = .;
    end;
    
    /* 只保留有滞后数据的观测 */
    if not missing(lag1_annual_adjusted_return) and year = lag1_year + 1;
    
    keep PERMNO year annual_adjusted_return lag1_annual_adjusted_return  /* 改为 PERMNO */
         trading_days lag1_trading_days lag1_year
         avg_daily_adjusted_return std_daily_adjusted_return;
    
    format annual_adjusted_return lag1_annual_adjusted_return percent8.2
           avg_daily_adjusted_return std_daily_adjusted_return percent8.4;
run;

/* 计算年化波动率 - 标准方法 */
proc sql;
    create table annual_volatility as
    select 
        PERMNO,  /* 改为 PERMNO */
        year(date) as year,
        
        /* 年化波动率 = 日收益率标准差 × √252 */
        std(ret) * sqrt(252) as annual_volatility format=percent8.2,
        
        /* 辅助统计量 */
        count(*) as trading_days,
        mean(ret) as avg_daily_return format=percent8.4,
        min(ret) as min_daily_return format=percent8.4,
        max(ret) as max_daily_return format=percent8.4,
        std(ret) as daily_volatility format=percent8.4
        
    from crsp_sorted
    where ret is not null
    group by PERMNO, calculated year  /* 改为 PERMNO */
    having count(*) >= 120  /* 至少120个交易日 */
    order by permno, year;  /* 改为 PERMNO */
quit;

/* 确保年度波动率数据按正确顺序排列 */
proc sort data=annual_volatility;
    by PERMNO year;  /* 改为 PERMNO */
run;

data lag_volatility_data;
    set annual_volatility;
    by PERMNO;  /* 改为 PERMNO */
    
    /* 直接将波动率设置为前一年的值 */
    annual_volatility = lag(annual_volatility);
    
    /* 移除第一个观测（没有前一年数据） */
    if not first.PERMNO;  /* 改为 PERMNO */
    
    format annual_volatility percent8.2;
run;

proc print data=lag_volatility_data (obs=20);
    title "使用前一年波动率的数据";
run;

/* 导出市场数据 */
proc sql;
    create table CRSP_data_clean as
    select 
        s.PERMNO,  /* 改为 PERMNO */
        s.year,
        
        /* 买卖差价数据 */
        s.annual_avg_spread,
        s.lag1_annual_spread,
        s.trading_days as spread_days,
        
        /* 当年收益率数据 */
        r.annual_adjusted_return,
        r.trading_days as return_days,
        
        /* 滞后一期收益率数据 */
        r_lag.annual_adjusted_return as lag1_annual_adjusted_return,
        r_lag.trading_days as lag1_return_days,
        r_lag.year as reference_year,  /* 滞后数据对应的实际年份 */
        
        /* 波动率数据 */
        v.annual_volatility,
        v.trading_days as vol_days
        
    from annual_spread_lag1 s
    left join annual_adjusted_returns r 
        on s.PERMNO = r.PERMNO and s.year = r.year  /* 改为 PERMNO */
    left join annual_adjusted_returns r_lag 
        on s.PERMNO = r_lag.PERMNO and s.year = r_lag.year + 1  /* 改为 PERMNO，滞后一年 */
    left join lag_volatility_data v 
        on s.PERMNO = v.PERMNO and s.year = v.year  /* 改为 PERMNO */
    order by s.PERMNO, s.year;  /* 改为 PERMNO */
quit;

/* 导出为CSV文件 */
proc export data=CRSP_data_clean
    outfile="C:\Users\MichealZhang\Desktop\ucl\raw data\CRSP_YEAR_CLEAN.csv"
    dbms=csv replace;
run;

/*计算导出审计数据*/

/* 导入数据 */
proc import datafile="C:\Users\MichealZhang\Desktop\ucl\raw data\audit_fee.csv"
    out=audit_fee
    dbms=csv replace;
    guessingrows=1000;
run;

/* 按FISCAL_YEAR排序 */
proc sort data=audit_fee out=audit_fee_sorted;
    by FISCAL_YEAR;
run;

/* 计算百分位数排名 */
proc rank data=audit_fee_sorted out=ranked groups=100;
    by FISCAL_YEAR;  
    var AUDIT_FEES NON_AUDIT_FEES TOTAL_FEES;
    ranks audit_rank non_audit_rank total_rank;
run;

/* 计算所需指标 */
data audit_fee_final;
    set ranked;
    
    /* 创建新变量 */
    cik = COMPANY_FKEY;
    fyear = FISCAL_YEAR;
    
    /* 计算对数 - 安全处理0值和负值 */
    if AUDIT_FEES > 0 then ln_audit_fees = log(AUDIT_FEES);
    else if AUDIT_FEES = 0 then ln_audit_fees = 0;  /* 0值设为0 */
    else ln_audit_fees = .;  /* 负值设为缺失 */
    
    if NON_AUDIT_FEES > 0 then ln_non_audit_fees = log(NON_AUDIT_FEES);
    else if NON_AUDIT_FEES = 0 then ln_non_audit_fees = 0;
    else ln_non_audit_fees = .;
    
    if TOTAL_FEES > 0 then ln_total_fees = log(TOTAL_FEES);
    else if TOTAL_FEES = 0 then ln_total_fees = .;
    else ln_total_fees = .;
    
    /* 计算比值 - 安全处理除零 */
    if TOTAL_FEES > 0 then do;
        audit_ratio = AUDIT_FEES / TOTAL_FEES;
        non_audit_ratio = NON_AUDIT_FEES / TOTAL_FEES;
    end;
    else do;
        audit_ratio = .;
        non_audit_ratio = .;
    end;
    
    /* 转换排名为百分位数比例 (0-1范围) */
audit_fees_pctrank = audit_rank / 99;     /* 0-1范围 */
non_audit_fees_pctrank = non_audit_rank / 99;
total_fees_pctrank = total_rank / 99;

    
    /* 格式化 */
    format audit_fees_pctrank non_audit_fees_pctrank total_fees_pctrank percent8.1;
    format audit_ratio non_audit_ratio percent8.2;
    
    keep cik fyear AUDIT_FEES NON_AUDIT_FEES TOTAL_FEES
         ln_audit_fees ln_non_audit_fees ln_total_fees
         audit_ratio non_audit_ratio
         audit_fees_pctrank non_audit_fees_pctrank total_fees_pctrank;
run;


    
/* 查看前20行数据 */
proc print data=audit_fee_final (obs=20);
    title "处理后数据前20行";
run;

/* 导出到CSV */
proc export data=audit_fee_final
    outfile="C:\Users\MichealZhang\Desktop\ucl\raw data\Audit_Fee_clean.csv"
    dbms=csv replace;
run;

/* 导入董事会数据 */
libname board "C:\Users\MichealZhang\Desktop\ucl\raw data\";

/* 查看数据结构和rowtype分布 */
proc freq data=board.board;
    tables rowtype / missing;
    title "rowtype字段分布情况";
run;

/* 筛选出rowtype为board member */
data board_members;
    set board.board;
    where upcase(strip(rowtype)) = 'BOARD MEMBER';
run;

/* 检查筛选结果 */
proc means data=board_members n;
    title "筛选后的观测数量";
run;

proc contents data=board.board varnum;
run;

/* 首先按companyid和annualreportdate排序 */
proc sort data=board.board out=sorted_board;
    by companyid annualreportdate;
run;

proc sql;
    create table role_summary as
    select 
        distinct strip(upcase(rolename)) as role_name
    from board.board
    where not missing(rolename)
    order by calculated role_name;
quit;

proc print data=role_summary;
    title "所有不同的角色名称";
run;

/* 计算董事长与CEO兼任情况，并包含需要的变量 */
proc sql;
    create table chairman_ceo_duality as
    select 
        companyid,
        year(annualreportdate) as fyear,
        
        /* 检查是否存在董事长与CEO兼任的情况 */
        max(case 
            when index(upcase(rolename), 'CHAIRMAN') > 0 and 
                 index(upcase(rolename), 'CEO') > 0 
            then 1 
            else 0 
        end) as chairman_ceo_duality,
        
        /* 包含需要keep的变量 */
        max(genderratio) as genderratio,
        max(numberdirectors) as numberdirectors,
        
        /* 可选：统计样本数量 */
        count(distinct directorid) as total_directors,
        count(*) as total_records
        
    from board.board
    group by companyid, calculated fyear
    order by companyid, calculated fyear;
quit;

/* 只保留需要的变量 */
data chairman_ceo_final;
    set chairman_ceo_duality; 
    keep companyid fyear chairman_ceo_duality genderratio numberdirectors;
run;

proc print data=chairman_ceo_final (obs=20);
    title "board处理后数据前20行";
run;

/* 保存为CSV文件 */
proc export data=chairman_ceo_final
    outfile="C:\Users\MichealZhang\Desktop\ucl\raw data\governance_metrics.csv"
    dbms=csv
    replace;
run;


/*合并最终数据集*/
/* 导入所有数据集 - 使用统一的小写命名 */
proc import datafile="data_FraudDetection_JAR2020.csv" out=main_data dbms=csv replace;
    getnames=yes;
	guessingrows=1000;
run;

proc import datafile="codelink.csv" out=codelink dbms=csv replace;
    getnames=yes;
	guessingrows=1000;
run;

proc import datafile="crsp_comp.csv" out=crsp_comp dbms=csv replace;
    getnames=yes;
	guessingrows=1000;
run;

proc import datafile="Audit_Fee_clean.csv" out=audit_fee dbms=csv replace;
    getnames=yes;
	guessingrows=1000;
run;

proc import datafile="CRSP_YEAR_CLEAN.csv" out=crsp_year dbms=csv replace;
    getnames=yes;
	guessingrows=1000;
run;

proc import datafile="governance_metrics.csv" out=governance dbms=csv replace;
    getnames=yes;
	guessingrows=1000;
run;

/* 第二步：处理主数据集，保留2000-2014年的数据 */
data main_data_filtered;
    set main_data;
    where fyear >= 2000 and fyear <= 2014;
run;

/* 1. 首先确保两个数据集都按gvkey和fyear排序 */
proc sort data=main_data_filtered;
    by gvkey fyear;
run;

proc sort data=crsp_comp;
    by gvkey fyear;
run;

proc sql;
    create table main_data_with_crsp as
    select 
        a.*,           /* 主数据集data_FraudDetection_JAR2020的所有变量 */
        b.LPERMNO,     /* 从crsp_comp添加LPERMNO */
        b.LPERMCO,     /* 从crsp_comp添加LPERMCO */
        b.CIK          /* 从crsp_comp添加CIK */
    from main_data_filtered a
    left join crsp_comp b
        on a.gvkey = b.gvkey and a.fyear = b.fyear;
quit;

/* 检查合并结果 */
proc means data=main_data_with_crsp n nmiss;
    var LPERMNO LPERMCO;
    title "主数据集与CRSP合并后的缺失值情况";
run;

/* 查看合并后的数据 */
proc print data=main_data_with_crsp (obs=20);
    var gvkey fyear LPERMNO LPERMCO;
    title "主数据集合并CRSP后的前20个观测";
run;

/* 统计匹配成功率 */
proc sql;
    select 
        count(*) as total_observations,
        sum(case when LPERMNO is not null then 1 else 0 end) as matched_permno,
        sum(case when LPERMCO is not null then 1 else 0 end) as matched_permco,
        calculated matched_permno / calculated total_observations as permno_match_rate format=percent8.2,
        calculated matched_permco / calculated total_observations as permco_match_rate format=percent8.2
    from main_data_with_crsp;
quit;

/* 进行codelink合并 */
proc sql;
    create table main_data_with_codelink as
    select 
        a.*,               /* 主数据集的所有变量 */
        b.companyid,       /* 从codelink添加companyid */
        b.PERMCO           /* 从codelink添加PERMCO */
    from main_data_with_crsp a
    left join codelink b
        on a.gvkey = b.gvkey;
quit;

/* 检查合并结果 */
proc means data=main_data_with_codelink n nmiss;
    var companyid PERMCO;
    title "合并后companyid和PERMCO的缺失值情况";
run;

/* 查看合并后的数据 */
proc print data=main_data_with_codelink (obs=20);
    var gvkey fyear companyid PERMCO LPERMNO LPERMCO;
    title "合并codelink后的前20个观测";
run;

/* 统计匹配成功率 */
proc sql;
    select 
        count(*) as total_observations,
        sum(case when companyid is not null then 1 else 0 end) as matched_companyid,
        sum(case when PERMCO is not null then 1 else 0 end) as matched_PERMCO,
        calculated matched_companyid / calculated total_observations as companyid_match_rate format=percent8.2,
        calculated matched_PERMCO / calculated total_observations as PERMCO_match_rate format=percent8.2
    from main_data_with_codelink;
quit;

/* 首先检查主数据集是否有必要的匹配变量 */
proc contents data=main_data_with_codelink;
    title "主数据集的变量列表";
run;

proc contents data=audit_fee;
    title "审计费用数据集的变量列表";
run;

proc contents data=crsp_year;
    title "CRSP年度数据集的变量列表";
run;

proc contents data=governance;
    title "公司治理数据集的变量列表";
run;

/* 最终合并所有数据集 */
proc sql;
    create table FINAL_MERGED_DATASET as
    select 
        /* 主数据集的所有变量 */
        main.*,
        
        /* 从AUDIT_FEE合并审计费用相关变量 */
        audit.ln_audit_fees,
        audit.ln_non_audit_fees,
        audit.ln_total_fees,
        audit.audit_ratio,
        audit.non_audit_ratio,
        audit.audit_fees_pctrank,
        audit.non_audit_fees_pctrank,
        audit.total_fees_pctrank,
        
        /* 从CRSP_YEAR合并市场数据变量 */
        crspyr.lag1_annual_spread,
        crspyr.lag1_annual_adjusted_return,
        crspyr.annual_volatility,
        
        /* 从GOVERNANCE合并公司治理变量 */
        gov.chairman_ceo_duality,
        gov.genderratio,
        gov.numberdirectors
        
    from MAIN_DATA_WITH_CODELINK as main
    
    /* 合并审计费用数据 */
    left join AUDIT_FEE as audit
        on main.cik = audit.cik and main.fyear = audit.fyear
        
    /* 合并市场数据 - 将CRSP_YEAR中的year视为fyear */
    left join CRSP_YEAR as crspyr
        on main.LPERMNO = crspyr.PERMNO and main.fyear = crspyr.year
        
    /* 合并公司治理数据 */
    left join GOVERNANCE as gov
        on main.companyid = gov.companyid and main.fyear = gov.fyear
        
    order by main.gvkey, main.fyear;
quit;


/* 检查最终合并结果 */
proc contents data=final_merged_dataset;
    title "最终合并数据集的结构";
run;

proc means data=final_merged_dataset n nmiss;
    var ln_audit_fees ln_non_audit_fees ln_total_fees
        lag1_annual_spread lag1_annual_adjusted_return annual_volatility
        chairman_ceo_duality genderratio numberdirectors;
    title "最终数据集的缺失值情况";
run;

/* 只查看前10个观测，避免输出过多 */
proc print data=final_merged_dataset (obs=100);
    title "最终数据集的前10个观测 - 所有变量";
run;

data final_merged_dataset_clean1;
    set final_merged_dataset;
    where not missing(LPERMNO) and not missing(LPERMCO);
run;

/* 更简洁的方法，列出所有需要检查的变量 */
proc sql;
    create table final_merged_dataset_clean1 as
    select *
    from final_merged_dataset
    where LPERMNO is not null and 
          LPERMCO is not null ;
quit;

/* 查看处理前后的观测数对比 */
proc sql;
    title "缺失值处理前后对比";
    select 
        (select count(*) from final_merged_dataset) as original_obs,
        (select count(*) from final_merged_dataset_clean) as cleaned_obs,
        calculated original_obs - calculated cleaned_obs as deleted_obs
    from final_merged_dataset(obs=1);
quit;


/* 导出为CSV文件 */
proc export data=final_merged_dataset_clean1
    outfile="final_merged_dataset1.csv"
    dbms=csv replace;
run;
